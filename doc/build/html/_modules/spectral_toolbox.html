
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>spectral_toolbox &#8212; Cyclops 1.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '1.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for spectral_toolbox</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env/ python3</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Objects for implementing spectral methods.</span>

<span class="sd">This module provides several methods contained within the SpectralToolbox class</span>
<span class="sd">for performing standard vector calculus operations in spectral space. It is</span>
<span class="sd">intended for use on a two-dimensional domain of equally-spaced gridpoints.</span>

<span class="sd">Classes</span>
<span class="sd">-------</span>
<span class="sd">- `SpectralToolbox` -- Superclass to implement standard techniques of spectral methods</span>

<span class="sd">Miscellaneous Functions for Unit Testing</span>
<span class="sd">----------------------------------------</span>
<span class="sd">- `test_func` -- Test function for unit testing</span>
<span class="sd">- `check_derivatives`</span>
<span class="sd">- `check_jacobian`</span>
<span class="sd">- `check_multiply`</span>
<span class="sd">- `check_laplacian`</span>

<span class="sd">All of the above compare the computed solution to an analytical solution.</span>

<span class="sd">Notes</span>
<span class="sd">-----</span>
<span class="sd">1) Invoking this module from the command line without any arguments will perform unit tests on the methods contained within.</span>

<span class="sd">2) The Fourier representation used is:</span>

<span class="sd">.. math:: u(x, y, t) = \\sum_{k_{1} = -N/2}^{N/2 -1} \\sum_{k_{2} = -N/2}^{N/2 - 1} \hat{u}(t) \\exp((2i\\pi/L)(k_{1}x + k_{2}y))</span>

<span class="sd">The spectrum is stored in the logical-to-mathematicians order, i.e. the wavenumbers are stored as:</span>

<span class="sd">+--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">|    (-N/2)(-N/2)    |  (-N/2)(-N/2 + 1)  |         ...        |   (-N/2)(N/2 - 1)  |</span>
<span class="sd">+--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">|  (-N/2 + 1)(-N/2)  |(-N/2 + 1)(-N/2 + 1)|         ...        |  (-N/2 + 1)(N/2 -1)|</span>
<span class="sd">+--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">|         ...        |         ...        |         ...        |         ...        |</span>
<span class="sd">+--------------------+--------------------+--------------------+--------------------+</span>
<span class="sd">|  (N/2 - 1)(-N/2)   | (N/2 - 1)(-N/2 + 1)|         ...        |  (N/2 - 1)(N/2 -1) |</span>
<span class="sd">+--------------------+--------------------+--------------------+--------------------+</span>

<span class="sd">With the Nyquist frequencies (corresponding to the most negative frequencies) located where one or both index = -N/2,</span>
<span class="sd">and the constant mode corresponding to :math:`k_{1} = 0`, :math:`k_{2} = 0` in the (N, N) position in the array.</span>

<span class="sd">2) The sign matrix, `sign_mat`, is used to relate the truncated Fourier series of a function, with wavenumbers that</span>
<span class="sd">run from [-N/2, N/2), with the FFT, with wavenumbers in [0, N). The point of doing this is to make the</span>
<span class="sd">operations in spectral space more intuitive from a mathematical perspective. We proceed by discretising the</span>
<span class="sd">desired function on an equispaced grid as above, noting that the sum runs from k = -N/2 to N/2 -1. In order to</span>
<span class="sd">make the sum correspond with the FFT, we perform the change of variables :math:`p = k + N/2`:</span>

<span class="sd">.. math:: f(x_{j}) = \\sum_{p=0}^{N-1} \\hat{f}(p-N/2) e^{2i\\pi k p/N}</span>

<span class="sd">.. math:: f(x_{j}) = \\sum_{p=0}^{N-1} \\hat{f}(p-N/2) (-1)^{p} e^{2i\\pi k/N}</span>

<span class="sd">Note that a factor of :math:`(-1)^{p}` is obtained. These alternating signs are implemented in the sign matrix</span>
<span class="sd">to permit a single multiplication operation.</span>

<span class="sd">See also</span>
<span class="sd">--------</span>
<span class="sd">numpy.fft, numpy</span>

<span class="sd">| Author: Adam G. Peddle</span>
<span class="sd">| Contact: ap553@exeter.ac.uk</span>
<span class="sd">| Version: 1.0</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">pyfftw</span>
    <span class="n">fftw_flag</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">fftw_flag</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="SpectralToolbox"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox">[docs]</a><span class="k">class</span> <span class="nc">SpectralToolbox</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Implements the required vector calculus techniques for spectral methods.</span>

<span class="sd">    This class stores the required constants as attributes to be used by its</span>
<span class="sd">    methods for spectral methods in 2 spatial dimensions.</span>

<span class="sd">    **Attributes**</span>

<span class="sd">    - `N` : The number of grid points in the domain, such that there are N X N equally-spaced points</span>
<span class="sd">    - `L` : The side length of the domain</span>
<span class="sd">    - `factor` : Factor arising in spectral differentiation on non-2pi domain (see below)</span>
<span class="sd">    - `sign_mat` : Matrix to reorder spectral space (see below)</span>
<span class="sd">    - `deriv_mat_x1`, deriv_mat_x2` : matrices for spectral differentiation in x1 and x2 directions (see calc_derivative method)</span>
<span class="sd">    - `laplace_op` : Array to implement Laplacian (see laplacian method)</span>

<span class="sd">    **Methods**</span>

<span class="sd">    - `dealias_pad` -- Pads the input array with zeros to prevent aliasing</span>
<span class="sd">    - `dealias_unpad` -- Removes the padding from dealias_pad</span>
<span class="sd">    - `forward_fft` -- Wrapper to perform Fast Fourier Transform with desired normalisation</span>
<span class="sd">    - `inverse_fft` -- Wrapper to invert FFT with desired normalisation</span>
<span class="sd">    - `calc_derivative` -- Computes 1st or 2nd order derivatives along x and/or y directions</span>
<span class="sd">    - `multiply_nonlinear` -- Multiplies two functions in a pseudo-spectral fashion</span>
<span class="sd">    - `solve_inverse_laplacian` -- Solves the inverse Laplacian problem with a chosen constant of integration</span>
<span class="sd">    - `jacobian1` -- Computes Jacobian of a single function</span>
<span class="sd">    - `jacobian` -- Computes Jacobian of two functions</span>
<span class="sd">    - `laplacian` -- Computes the Laplacian of a given function</span>

<span class="sd">    **Example**</span>

<span class="sd">    | ``&gt;&gt; st = SpectralToolbox(128, 2*np.pi)``</span>
<span class="sd">    | ``&gt;&gt; du_dx = st.calc_derivative(A, &#39;x&#39;)  # Compute x-derivative``</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fftw_flag</span> <span class="o">=</span> <span class="n">fftw_flag</span>
        <span class="k">if</span> <span class="n">fftw_flag</span><span class="p">:</span>
            <span class="n">pyfftw</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">cache</span><span class="o">.</span><span class="n">enable</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fft_use</span> <span class="o">=</span> <span class="n">pyfftw</span><span class="o">.</span><span class="n">interfaces</span><span class="o">.</span><span class="n">numpy_fft</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fft_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">N</span> <span class="o">=</span> <span class="n">N</span>
        <span class="k">if</span> <span class="n">N</span><span class="o">%</span><span class="mi">2</span><span class="p">:</span> <span class="c1"># Methods are not currently implemented for odd values of N</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;N must be even&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">L</span> <span class="o">=</span> <span class="n">L</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">factor</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="n">L</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">M</span> <span class="o">=</span> <span class="mi">3</span><span class="o">*</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span>
        <span class="c1">#self.M = 2*N</span>

        <span class="c1"># Create sign matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;complex&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat</span><span class="p">[</span><span class="n">k1</span><span class="p">,</span><span class="n">k2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">**</span><span class="p">(</span><span class="n">k1</span><span class="o">+</span><span class="n">k2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat_fft_big</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat_fft_small</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span><span class="o">/</span><span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat_ifft_big</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sign_mat</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat_ifft_small</span> <span class="o">=</span> <span class="p">(</span><span class="n">N</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">sign_mat</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">N</span><span class="p">]</span>

        <span class="c1"># Create derivative matrices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x1</span><span class="p">[</span><span class="n">k1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">k2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k1</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x2</span><span class="p">[</span><span class="n">k1</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span><span class="n">k2</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">k2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">factor</span>

        <span class="c1"># Create laplacian matrix. Factor of multiplication is included</span>
        <span class="c1"># implicitly due to inclusion in derivative matrices.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laplace_op</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">laplace_op</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x2</span><span class="o">**</span><span class="mi">2</span>

<div class="viewcode-block" id="SpectralToolbox.dealias_pad"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.dealias_pad">[docs]</a>    <span class="k">def</span> <span class="nf">dealias_pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Pads the spectrum with zeros in high frequencies for aliasing control.</span>

<span class="sd">        This method doubles the size of the spectrum and sets all high frequencies to zero</span>
<span class="sd">        for aliasing control. This causes the resolution in real space (after inverse FFT)</span>
<span class="sd">        to be doubled. The higher frequencies are then discarded upon returning to</span>
<span class="sd">        spectral space. The array is doubled in a symmetric fashion.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `A` : the spectrum to be padded</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `B` : the padded spectrum</span>

<span class="sd">        **See also**</span>

<span class="sd">        dealias_unpad</span>

<span class="sd">        **Example**</span>

<span class="sd">        | ``&gt;&gt; A = np.ones((2,2), dtype = complex)``</span>
<span class="sd">        | ``&gt;&gt; st.dealias_pad(A)``</span>
<span class="sd">        | ``&gt;&gt; array([[ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],``</span>
<span class="sd">        |          ``[ 0.+0.j,  1.+0.j,  1.+0.j,  0.+0.j],``</span>
<span class="sd">        |          ``[ 0.+0.j,  1.+0.j,  1.+0.j,  0.+0.j],``</span>
<span class="sd">        |          ``[ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j]])``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#m, n = A.shape</span>
        <span class="c1">#B = np.zeros((2*m, 2*n), dtype = complex)</span>
        <span class="c1">#B[m//2:3*m//2, n//2:3*n//2] = A[:,:]</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">)</span>
        <span class="n">B</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">//</span><span class="mi">6</span><span class="p">:</span><span class="mi">5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">//</span><span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">//</span><span class="mi">6</span><span class="p">:</span><span class="mi">5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">//</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:,:]</span>

        <span class="c1">#np.set_printoptions(precision=1, linewidth=240)</span>
        <span class="c1">#print(B)</span>
        <span class="c1">#exit()</span>

        <span class="k">return</span> <span class="n">B</span></div>

<div class="viewcode-block" id="SpectralToolbox.dealias_unpad"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.dealias_unpad">[docs]</a>    <span class="k">def</span> <span class="nf">dealias_unpad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Unpads the spectrum, removing high frequencies, for aliasing control.</span>

<span class="sd">        This method reverses the padding set up in the dealias_pad method,</span>
<span class="sd">        returning the size of the spectrum to the initial value upon returning</span>
<span class="sd">        to spectral space. The highest half of the frequencies are discarded.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `A` : the spectrum to be unpadded</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `B` : the unpadded spectrum</span>

<span class="sd">        **See also**</span>

<span class="sd">        dealias_pad</span>

<span class="sd">        **Example**</span>

<span class="sd">        | ``&gt;&gt; A = array([[ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j],``</span>
<span class="sd">        |            ``[ 0.+0.j,  1.+0.j,  1.+0.j,  0.+0.j],``</span>
<span class="sd">        |            ``[ 0.+0.j,  1.+0.j,  1.+0.j,  0.+0.j],``</span>
<span class="sd">        |            ``[ 0.+0.j,  0.+0.j,  0.+0.j,  0.+0.j]])``</span>
<span class="sd">        | ``&gt;&gt; st.dealias_unpad(A)``</span>
<span class="sd">        | ``&gt;&gt; array([[ 1.+0.j,  1.+0.j],``</span>
<span class="sd">        |        ``[ 1.+0.j,  1.+0.j]])``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">#m, n = A.shape</span>
        <span class="c1">#B = np.zeros((m//2, n//2), dtype = complex)</span>
        <span class="c1">#B = A[m//4:3*m//4, n//4:3*n//4]</span>

        <span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">)</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">//</span><span class="mi">6</span><span class="p">:</span><span class="mi">5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">//</span><span class="mi">6</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">//</span><span class="mi">6</span><span class="p">:</span><span class="mi">5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="o">//</span><span class="mi">6</span><span class="p">]</span>

        <span class="c1">#np.set_printoptions(precision=1, linewidth=240)</span>
        <span class="c1">#print(B)</span>
        <span class="c1">#exit()</span>

        <span class="k">return</span> <span class="n">B</span></div>

<div class="viewcode-block" id="SpectralToolbox.forward_fft"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.forward_fft">[docs]</a>    <span class="k">def</span> <span class="nf">forward_fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_in</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper to implement the forward Fast Fourier Transform.</span>

<span class="sd">        This method implements the forward FFT (i.e. from real-space</span>
<span class="sd">        to spectral space). The values are normalised such that the spectral</span>
<span class="sd">        coefficient corresponds to a wave of exactly that amplitude, rather</span>
<span class="sd">        than the normalised value returned by the standard FFT. The sign matrix</span>
<span class="sd">        is used to yield a spectrum running from -N/2 to N/2 -1.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `array_in` : the array of real values</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `out` : the spectral coefficients, in the chosen framework</span>

<span class="sd">        **See Also**</span>

<span class="sd">        Note 2 in the class header (`sign matrix`), inverse_fft</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find side length, as real array may or may not be doubled for</span>
        <span class="c1"># aliasing control</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">array_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
            <span class="c1">#out = np.fft.fft2(self.sign_mat_fft_small*array_in)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_use</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sign_mat_fft_small</span><span class="o">*</span><span class="n">array_in</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft_use</span><span class="o">.</span><span class="n">fft2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sign_mat_fft_big</span><span class="o">*</span><span class="n">array_in</span><span class="p">)</span>
            <span class="c1">#out = np.fft.fft2(self.sign_mat_fft_big*array_in)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="SpectralToolbox.inverse_fft"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.inverse_fft">[docs]</a>    <span class="k">def</span> <span class="nf">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_in</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Wrapper to implement the inverse Fast Fourier Transform.</span>

<span class="sd">        This method implements the inverse FFT (i.e. from spectral space</span>
<span class="sd">        to real space). The values are normalised such that the spectral</span>
<span class="sd">        coefficient corresponds to a wave of exactly that amplitude, rather</span>
<span class="sd">        than the normalised value returned by the standard FFT. The sign matrix</span>
<span class="sd">        is used to yield a spectrum running from -N/2 to N/2 -1.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `array_in` : the array of spectral coefficients</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `out` : the real values at gridpoints, in the chosen framework</span>

<span class="sd">        **See Also**</span>

<span class="sd">        Note 2 in the class header (sign matrix), forward_fft</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find side length, as spectrum may or may not have been doubled</span>
        <span class="c1"># for aliasing control</span>
        <span class="n">side</span> <span class="o">=</span> <span class="n">array_in</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">side</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat_ifft_small</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_use</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">array_in</span><span class="p">)</span>
            <span class="c1">#out = self.sign_mat_ifft_small*np.fft.ifft2(array_in)</span>
        <span class="k">elif</span> <span class="n">side</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">M</span><span class="p">:</span>
            <span class="c1">#out = self.sign_mat_ifft_big*np.fft.ifft2(array_in)</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sign_mat_ifft_big</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">fft_use</span><span class="o">.</span><span class="n">ifft2</span><span class="p">(</span><span class="n">array_in</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="SpectralToolbox.calc_derivative"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.calc_derivative">[docs]</a>    <span class="k">def</span> <span class="nf">calc_derivative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_in</span><span class="p">,</span> <span class="n">direction1</span><span class="p">,</span> <span class="n">direction2</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes 1st or 2nd order derivatives in x and/or y directions.</span>

<span class="sd">        This method implements spectral (spatial) differentiation through the use of</span>
<span class="sd">        the derivative matrices, stored as attributes of the SpectralToolbox class.</span>
<span class="sd">        The Nyquist frequency is treated specially for odd orders of multiplication.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `array_in` : the array of spectral coefficients to be differentiated</span>
<span class="sd">        - `direction1` : the first direction to be differentiated (&#39;x&#39; or &#39;y&#39;)</span>
<span class="sd">        - `direction2` : the optional second direction to be differentiated (&#39;x&#39; or &#39;y&#39;)</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `out` : the differentiated spectrum</span>

<span class="sd">        **Notes**</span>

<span class="sd">        Recall that the function, u, is represented in Fourier space as:</span>

<span class="sd">        .. math:: u(x, y, t) = \\sum_{k_{1} = -N/2}^{N/2 -1} \\sum_{k_{2} = -N/2}^{N/2 - 1} \\hat{u}(t) \\exp((2i\\pi/L)(k_{1}x + k_{2}y))</span>

<span class="sd">        Then the first derivative in the x-direction, as :math:`\\hat{u}(t)` is not a function of space, is simply:</span>

<span class="sd">        .. math:: \\frac{\\partial u(x, y, t)}{\\partial x} = \\sum_{k_{1} = -N/2}^{N/2 -1} \\sum_{k_{2} = -N/2}^{N/2 - 1} \\hat{u}(t)  (2i\\pi k_{1}/L)  \\exp((2i\\pi/L)(k_{1}x + k_{2}y))</span>

<span class="sd">        Thus, differentiation in spectral space is a matter of multiplying each Fourier mode by the length factor (:math:`B=2\\pi/L`) times i times the associated wavenumber.</span>
<span class="sd">        To reduce loops and make the implementation simpler, these modes are contained in the derivatrive matrices, which take the form:</span>

<span class="sd">        .. math:: \\text{deriv_mat_x1} = \\left[\\begin{array}{cccc}</span>
<span class="sd">                        iBk_{1} &amp; iBk_{1} &amp; \cdots &amp; iBk_{1} \\\\</span>
<span class="sd">                       iBk_{2} &amp; iBk_{2} &amp; \cdots &amp; iBk_{2}\\\\</span>
<span class="sd">                       \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\</span>
<span class="sd">                       iBk_{n} &amp; iBk_{n} &amp; \cdots &amp; iBk_{n} \\end{array}\\right]</span>

<span class="sd">        and:</span>

<span class="sd">        .. math:: \\text{deriv_mat_x2} = \\left[\\begin{array}{cccc}</span>
<span class="sd">                        iBk_{1} &amp; iBk_{2} &amp; \cdots &amp; iBk_{n} \\\\</span>
<span class="sd">                       iBk_{1} &amp; iBk_{2} &amp; \cdots &amp; iBk_{n}\\\\</span>
<span class="sd">                       \\vdots &amp; \\vdots &amp; \\ddots &amp; \\vdots \\\\</span>
<span class="sd">                       iBk_{1} &amp; iBk_{2} &amp; \cdots &amp; iBk_{n} \\end{array}\\right]</span>

<span class="sd">        **Example**</span>

<span class="sd">        | ``&gt;&gt; A = array([[ 1.+0.j,  1.+0.j],``</span>
<span class="sd">        |           ``[ 1.+0.j,  1.+0.j]])``</span>
<span class="sd">        |</span>
<span class="sd">        | ``&gt;&gt; st.calc_derivative(A, &#39;x&#39;)``</span>
<span class="sd">        | ``&gt;&gt; array([[ 0.+0.j,  0.+0.j],``</span>
<span class="sd">        |        ``[ 0.+0.j,  0.+0.j]])``</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">array_in</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">direction1</span> <span class="o">!=</span> <span class="n">direction2</span><span class="p">:</span>
            <span class="c1">#Remove Nyquist frequency for even sample size and odd order of differentiation</span>
            <span class="k">if</span> <span class="n">direction1</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span> <span class="ow">or</span> <span class="n">direction2</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">if</span> <span class="n">direction1</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span> <span class="ow">or</span> <span class="n">direction2</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                <span class="n">A</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Note that &#39;x&#39; corresponds to the x1 direction, and &#39;y&#39; to the</span>
        <span class="c1"># x2 direction</span>
        <span class="c1"># Perform first derivative in desired direction</span>
        <span class="k">if</span> <span class="n">direction1</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x1</span><span class="o">*</span><span class="n">A</span>
        <span class="k">elif</span> <span class="n">direction1</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x2</span><span class="o">*</span><span class="n">A</span>

        <span class="c1"># Perform second derivative in desired direction</span>
        <span class="k">if</span> <span class="n">direction2</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x1</span><span class="o">*</span><span class="n">out</span>
        <span class="k">elif</span> <span class="n">direction2</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">deriv_mat_x2</span><span class="o">*</span><span class="n">out</span>

        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="SpectralToolbox.multiply_nonlinear"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.multiply_nonlinear">[docs]</a>    <span class="k">def</span> <span class="nf">multiply_nonlinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array1</span><span class="p">,</span> <span class="n">array2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Simple method for multiplying two sets of data when nonlinearities are involved</span>
<span class="sd">        and transformation into real space is necessary.</span>

<span class="sd">        This method computes the product of two quantities defined in spectral space</span>
<span class="sd">        using a pseudo-spectral method, i.e. the multiplication is performed in realspace.</span>
<span class="sd">        The spectra are padded for aliasing control and must be of the same dimension.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `array_1`, `array_2` : the input spectra to be multiplied</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `f3_hat` : the spectrum obtainined from the multiplication</span>

<span class="sd">        **See Also**</span>

<span class="sd">        dealias_pad, dealias_unpad</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># compute grid values via FFT</span>
        <span class="n">f1_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">array1</span><span class="p">))</span>
        <span class="n">f2_vals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">array2</span><span class="p">))</span>

        <span class="c1"># multiply in space</span>
        <span class="n">f3_vals</span> <span class="o">=</span> <span class="n">f1_vals</span> <span class="o">*</span> <span class="n">f2_vals</span>

        <span class="c1"># compute Fourier coeffs</span>
        <span class="n">f3_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dealias_unpad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forward_fft</span><span class="p">(</span><span class="n">f3_vals</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">f3_hat</span></div>

<div class="viewcode-block" id="SpectralToolbox.solve_inverse_laplacian"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.solve_inverse_laplacian">[docs]</a>    <span class="k">def</span> <span class="nf">solve_inverse_laplacian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_in</span><span class="p">,</span> <span class="n">zero_mode_val</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the inverse Laplacian problem in spectral space.</span>

<span class="sd">        This method implements the inverse Laplacian, i.e. it finds u in:</span>

<span class="sd">        .. math:: \\nabla^{2}u = f</span>

<span class="sd">        with a constant of integration which must be specified by the user.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `array_in` : the known spectrum, f</span>
<span class="sd">        - `zero_mode_val` : the constant of integration, corresponding to the constant Fourier mode</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `array_out` : the desired quantity, u</span>

<span class="sd">        **See Also**</span>

<span class="sd">        calc_derivative</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialise output array, u</span>
        <span class="n">array_out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span><span class="p">),</span> <span class="n">dtype</span> <span class="o">=</span> <span class="nb">complex</span><span class="p">)</span>
        <span class="n">N</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">N</span>

        <span class="k">for</span> <span class="n">k1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">k2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">k1</span> <span class="o">==</span> <span class="n">k2</span> <span class="ow">and</span> <span class="n">k1</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Set zero-th mode, i.e. constant of integration</span>
                    <span class="n">array_out</span><span class="p">[</span><span class="n">k1</span> <span class="o">+</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">k2</span> <span class="o">+</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">zero_mode_val</span>
                <span class="k">else</span><span class="p">:</span>  <span class="c1"># All other modes are found by inverting the spectral differentiation factor</span>
                    <span class="n">laplace_op</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">k1</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">k2</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">factor</span><span class="o">**</span><span class="mi">2</span>
                    <span class="n">array_out</span><span class="p">[</span><span class="n">k1</span> <span class="o">+</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">k2</span> <span class="o">+</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">array_in</span><span class="p">[</span><span class="n">k1</span> <span class="o">+</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">,</span> <span class="n">k2</span> <span class="o">+</span> <span class="n">N</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="n">laplace_op</span>

        <span class="k">return</span> <span class="n">array_out</span></div>

<div class="viewcode-block" id="SpectralToolbox.jacobian1"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.jacobian1">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">A</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Jacobian for a single scalar-valued function.</span>

<span class="sd">        This method implements the Jacobian for a single function, such as a streamfunction</span>
<span class="sd">        or velocity potential. The Jacobian in this case takes the form:</span>

<span class="sd">        .. math:: J(u) = u_{xx}u_{yy} - 2u_{xy}</span>

<span class="sd">        where subscripts denote partial derivatives.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `A` : The function of which the Jacobian is desired</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `J` : The Fourier modes of the Jacobian</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute second derivatives in spectral space</span>
        <span class="n">A_x_x_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">A_y_y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">A_x_y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">A_y_x_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>

        <span class="c1"># Compute realspace representations for multiplication</span>
        <span class="n">A_x_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">A_x_x_hat</span><span class="p">))</span>
        <span class="n">A_y_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">A_y_y_hat</span><span class="p">))</span>
        <span class="n">A_x_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">A_x_y_hat</span><span class="p">))</span>
        <span class="n">A_y_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">A_y_x_hat</span><span class="p">))</span>

        <span class="c1"># Multiply in realspace</span>
        <span class="n">J_canonical</span> <span class="o">=</span> <span class="p">(</span><span class="n">A_x_x</span><span class="o">*</span><span class="n">A_y_y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">A_x_y</span><span class="o">*</span><span class="n">A_y_x</span><span class="p">)</span>

        <span class="c1"># Return to Fourier space and return spectrum</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dealias_unpad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forward_fft</span><span class="p">(</span><span class="n">J_canonical</span><span class="p">))</span></div>

<div class="viewcode-block" id="SpectralToolbox.jacobian"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.jacobian">[docs]</a>    <span class="k">def</span> <span class="nf">jacobian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Jacobian for a two scalar-valued functions.</span>

<span class="sd">        This method implements the Jacobian for two scalar-valued functions. The Jacobian</span>
<span class="sd">        may be written as:</span>

<span class="sd">        .. math:: J(A, B) = A_{x}B_{y} - A_{y}B_{x}</span>

<span class="sd">        where subscripts denote partial derivatives.</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `A`, `B` : The Fourier representations of the functions A and B (above). Must have the same dimensions.</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `J` : The Fourier modes of the Jacobian</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Compute the derivatives spectrally</span>
        <span class="n">A_x_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">A_y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
        <span class="n">B_x_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
        <span class="n">B_y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>

        <span class="c1"># Compute the values in realspace for multiplication</span>
        <span class="n">A_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">A_x_hat</span><span class="p">))</span>
        <span class="n">A_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">A_y_hat</span><span class="p">))</span>
        <span class="n">B_y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">B_y_hat</span><span class="p">))</span>
        <span class="n">B_x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dealias_pad</span><span class="p">(</span><span class="n">B_x_hat</span><span class="p">))</span>

        <span class="c1"># Compute the Jacobian</span>
        <span class="n">J_canonical</span> <span class="o">=</span> <span class="p">(</span><span class="n">A_x</span><span class="o">*</span><span class="n">B_y</span><span class="p">)</span> <span class="o">-</span> <span class="p">(</span><span class="n">B_x</span><span class="o">*</span><span class="n">A_y</span><span class="p">)</span>

        <span class="c1"># Return to spectral space the return</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dealias_unpad</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forward_fft</span><span class="p">(</span><span class="n">J_canonical</span><span class="p">))</span></div>

<div class="viewcode-block" id="SpectralToolbox.laplacian"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.SpectralToolbox.laplacian">[docs]</a>    <span class="k">def</span> <span class="nf">laplacian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">array_in</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the Laplacian of a given function in spectral space.</span>

<span class="sd">        The Laplacian may be written as:</span>

<span class="sd">        .. math:: f = \\nabla^{2}u = \\nabla \\cdot \\nabla u</span>

<span class="sd">        **Parameters**</span>

<span class="sd">        - `array_in` : the value of interest, in Fourier space</span>

<span class="sd">        **Returns**</span>

<span class="sd">        - `array_out` : the Laplacian of the input array</span>

<span class="sd">        **See Also**</span>

<span class="sd">        calc_derivative</span>

<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Call-through to Laplacian operator, already computed</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">laplace_op</span><span class="o">*</span><span class="n">array_in</span></div></div>

<span class="c1">#Unit Tests Below#</span>

<span class="k">def</span> <span class="nf">testfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">):</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">8.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">11.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

<div class="viewcode-block" id="check_jacobian"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.check_jacobian">[docs]</a><span class="k">def</span> <span class="nf">check_jacobian</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">u_analytical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="n">n1</span><span class="o">/</span><span class="n">N</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="n">n2</span><span class="o">/</span><span class="n">N</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">testfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="n">u_analytical</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mf">4.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mf">64.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">8.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">11.0</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">*</span>\
                                  <span class="p">(</span><span class="o">-</span><span class="mf">4.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mf">121.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">8.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">11.0</span><span class="o">*</span><span class="n">y</span><span class="p">))</span> <span class="o">-</span> \
                                  <span class="p">(</span><span class="o">-</span><span class="mf">4.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mf">88.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">8.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">11.0</span><span class="o">*</span><span class="n">y</span><span class="p">))</span><span class="o">**</span><span class="mi">2</span>

    <span class="n">u_hat</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">forward_fft</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">u_hat_pad</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">jacobian1</span><span class="p">(</span><span class="n">u_hat</span><span class="p">)</span>
    <span class="n">u_num_pad</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="n">u_hat_pad</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">u_num_pad</span> <span class="o">-</span> <span class="n">u_analytical</span><span class="p">)))</span></div>

<div class="viewcode-block" id="check_laplacian"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.check_laplacian">[docs]</a><span class="k">def</span> <span class="nf">check_laplacian</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
    <span class="n">u_analytical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="n">n1</span><span class="o">/</span><span class="n">N</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="n">n2</span><span class="o">/</span><span class="n">N</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">testfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="n">u_analytical</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">8.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mf">185.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">8.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">11.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

    <span class="n">u_hat</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">forward_fft</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">u_hat</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">laplacian</span><span class="p">(</span><span class="n">u_hat</span><span class="p">)</span>
    <span class="n">u_num</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="n">u_hat</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">u_num</span> <span class="o">-</span> <span class="n">u_analytical</span><span class="p">)))</span><span class="c1">#/(u_analytical)</span></div>

<div class="viewcode-block" id="check_derivatives"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.check_derivatives">[docs]</a><span class="k">def</span> <span class="nf">check_derivatives</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">u_analytical_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>
    <span class="n">u_analytical_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="n">n1</span><span class="o">/</span><span class="n">N</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="n">n2</span><span class="o">/</span><span class="n">N</span>
            <span class="n">u</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">testfunc</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">)</span>
            <span class="n">u_analytical_x</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">-</span> <span class="mf">8.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">8.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">11.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
            <span class="n">u_analytical_y</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span> <span class="o">+</span> <span class="mf">11.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">8.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">11.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>

    <span class="n">u_hat</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">forward_fft</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
    <span class="n">u_hat_x</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">u_hat</span><span class="p">,</span> <span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="n">u_hat_y</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">calc_derivative</span><span class="p">(</span><span class="n">u_hat</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">)</span>
    <span class="n">u_num_x</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="n">u_hat_x</span><span class="p">)</span>
    <span class="n">u_num_y</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="n">u_hat_y</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">u_num_x</span> <span class="o">-</span> <span class="n">u_analytical_x</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">u_num_y</span> <span class="o">-</span> <span class="n">u_analytical_y</span><span class="p">)))</span></div>

<div class="viewcode-block" id="check_multiply"><a class="viewcode-back" href="../spectral_toolbox.html#spectral_toolbox.check_multiply">[docs]</a><span class="k">def</span> <span class="nf">check_multiply</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">u1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">u2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="nb">complex</span><span class="p">)</span>
    <span class="n">u_analytical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">N</span><span class="p">,</span><span class="n">N</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">n1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">n2</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">N</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="n">n1</span><span class="o">/</span><span class="n">N</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">L</span><span class="o">*</span><span class="n">n2</span><span class="o">/</span><span class="n">N</span>
            <span class="n">u1</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">2.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">4.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span>
            <span class="n">u2</span><span class="p">[</span><span class="n">n1</span><span class="p">,</span><span class="n">n2</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">y</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="mf">3.0</span><span class="o">*</span><span class="n">x</span><span class="p">)</span>

    <span class="n">u_analytical</span> <span class="o">=</span> <span class="n">u1</span><span class="o">*</span><span class="n">u2</span>
    <span class="n">u_hat1</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">forward_fft</span><span class="p">(</span><span class="n">u1</span><span class="p">)</span>
    <span class="n">u_hat2</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">forward_fft</span><span class="p">(</span><span class="n">u2</span><span class="p">)</span>
    <span class="n">u_hat</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">multiply_nonlinear</span><span class="p">(</span><span class="n">u_hat1</span><span class="p">,</span> <span class="n">u_hat2</span><span class="p">)</span>
    <span class="n">u_num</span> <span class="o">=</span> <span class="n">st</span><span class="o">.</span><span class="n">inverse_fft</span><span class="p">(</span><span class="n">u_hat</span><span class="p">)</span>

    <span class="k">return</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">u_num</span> <span class="o">-</span> <span class="n">u_analytical</span><span class="p">)))</span><span class="c1">#/(u_analytical)</span></div>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>

    <span class="n">np</span><span class="o">.</span><span class="n">set_printoptions</span><span class="p">(</span><span class="n">linewidth</span> <span class="o">=</span> <span class="mi">140</span><span class="p">,</span> <span class="n">precision</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span>
    <span class="n">N</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">SpectralToolbox</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>

    <span class="n">N</span> <span class="o">=</span> <span class="mi">256</span>
    <span class="n">L</span> <span class="o">=</span> <span class="mf">2.0</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mf">2.0</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">SpectralToolbox</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">check_derivatives</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in x-derivative is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in y-derivative is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">check_laplacian</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in Laplacian is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">check_jacobian</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in Jacobian is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">check_multiply</span><span class="p">(</span><span class="n">st</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">L</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Error in Multiply is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">out</span><span class="p">))</span>

</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
            <p class="logo"><a href="../index.html">
              <img class="logo" src="../_static/Cyclops_1.jpg" alt="Logo"/>
            </a></p><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Adam G Peddle.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>